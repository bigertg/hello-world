### http 三次握手 四次挥手 以及请求头信息

1. 三次握手（确认双方都能正常发送和接收）

   1. 一次握手 -- 客户端-  发送标有SYN的数据包         -服务端
   2. 二次握手 -- 服务端-  发送标有SYN/ACK的数据包 -客户端
   3. 三次握手 -- 发送端-   发送标有ACK的数据包           -服务端

2. 四次挥手(要求双方都完毕)

   1. 客户端-发送FIN用来关闭客户端到服务器的数据传送
   2. 服务端-收到FIN，返回ACK
   3. 服务端-关闭连接，发送一个FIN给客户端
   4. 客户端-发回ACK报文确认

3. 根据真实ip限制地区访问

   1. 基本逻辑：获取用户ip地址，如果是内网ip，直接通过，如果是外网ip,使用第三方接口（百度普通ip定位）进行查询，根据返回的地址进行判断是否拥有该活动权限

   2. 请求头

      1. X-Forwarded-For 每经过一个代理，都会把代理客户端ip添加在后面
      2. X-Real-IP  上一级代理的客户端ip
      3. Remote_Addr  最后一个代理的服务器IP，如果没有代理则为真实IP

      

### 单点登入 

1. Spring Security + jwt +redis 
2. JWT 
   1. 无状态设计，用户信息存在jwt密文数据里，解析密文就能拿到用户信息，本质上就是不存储登入授权，减少数据库压力
   2. 头部、荷载、签名
      1. 头部：描述JWT元数据的JSON对象
      2. 荷载：消息体，可根据业务需求自行添加
      3. 签名sign: 将头部和荷载分别用base64加密后，用‘.’拼接后再配合秘钥(自定义)HMAC SHA-256进行加密，最后再次base64加密
   3. 缺点：一旦jwt签发，有效期内一直有效，无法进行token失效操作
3. SpringSecurity 身份认证和授权
   1. 不同方式的用户登入
      1. 自定义类继承AbstractAuthenticationToken抽象类（账号密码）
      2. 自定义一个AuthenticationProvider实现类（可以写验证逻辑），重写authenticate方法和supports方法（要根据这个去适配自定义的AuthenticationToken类）
      3. 在配置文件进行注册
   2. 插入自定义过滤器
   3. 插拔式加解密方式
4. JWT加密token(key),Redis保存用户信息

### 微服务拆分的粒度

1. 
   1. 分2种类型，一种类似OA系统，业务相对独立；另一种类似资产管理，底层耦合较重
   2. 应用功能拆，数据库也要拆
   3. 数据怎么拆，尽量减少跨库查询和分布式事务
2. 分离出非核心业务
   1. 检验行为
   2. 短信、邮件发送
3. 分析业务，将比较独立的业务拆分成一个微服务
4. 如果数据层耦合较重，则分析业务的每个阶段，根据不同阶段关联性的强弱来划分，尽量减少跨库查询和分布式事务

### AES接口参数加密

1. 基本流程：前端使用AES对接口进行加密，同时生成sign标签，sign标签页放入到加密数据中 -----> 后端接收密文后先解密，再验签，验签失败则为无效数据
   1. 加密：AES
      1. AES是对称加密算法 C=E(K，P)  C:经过处理后的密文，E:AES加密函数，K:秘钥(128位 192位 256位)，P：明文
      2. AES-128 加密10轮，AES-192 12轮，AES-256 14轮  前面N-1轮都是统一流程：字节代换、行位移、列混合和轮密钥加；最后一轮迭代不执行列混合
      3. 秘钥（自定义）：请求头token + 时间戳前八位   
   2. Sign标签（MD5生成摘要）
      1. 生成规则：所有请求参数，random(随机数)，timestamp  , token,根据key值排序，以key=value&拼接成字符串，再进行MD5加密
      2. 校验：后端拦截器，根据此方法进行MD5加密，校验 一致性，再进行AES解密
      3. 遇到的问题，request的参数只能读取一次，使用包装类解决问题
         1. 写一个子类继承**httpservletRequestWrapper**包装类
         2. 重写getInputstream的方法
            1. 自定义一个字节数组 requestBody用于保存数据
            2. 将数据流中的数据读出来，在回填到requestBody之中（首次）
            3. 后续直接从requestBody中拿
         3. 加入到过滤链之中

### Redis的使用有什么作用

1. 缓存
2. 分布式锁
   1. set  ex px  nx +  校验唯一随机值
   2. 再加强：开源框架Redisson
   3. 多机实现的分布式锁Redlock
3. 消息队列
4. 淘汰策略
   1. 定时删除
   2. 惰性删除  
5. 穿透：
   1. 没查到就把key写到redis中
   2. 布隆过滤器，过滤无效请求 hash算法
6. 雪崩：
   1. 事前：redis集群
   2. 事中：本地缓存、限流，服务降级
   3. 事后：redis持久化，数据恢复
7. 有一个数据设置了1小时过期，结果30分钟还没到就过期了
   1. 典型的内存不足问题
   2. 当内存不足时，redis会执行淘汰策略
      1. 从设置过期时间的key中删除最少使用的
      2. 从所有key中进行删除
      3. 从设置过期时间的key中随机删除
      4. 从所有key中随机删除
      5. 从设置时间过期的key中删除最近过期的
      6. 不处理

Redis + token实现幂等性

1. 第一阶段：在提交订单之前，根据用户信息向订单系统申请一次token请求，支付系统将token保存到Redis缓存中，为第二阶段支付使用
2. 第二阶段：带上token发起支付请求，系统查看redis是否存在此token，如果存在，则删除缓存开始后续逻辑；如果不存在，表示非法请求；

 

**拓展**：Redis分布式锁

1. ​	查询Redis缓存是否存在该订单的key,如果不存在，则新增key为订单号（直接插入）SETNX

   1. SETNX (set if not exists)  SETNX key value当且仅当key不存在，将key的值设为value,并返回1；若key已存在，不做任何动作，并返回0   ---------------这个已经过时了，用set加参数同样能实现
   2. GETSET key value 将给定的值设为value,并返回key的旧值，当key存在但不是字符串，返回一个错误，当key不存在时，返回nil。
   3. SET key value EX  $expire_time NX     EX：设置过期时间    NX:  只有当值不存在时才操作，成功返回OK，失败返回nil（相当于SETNX）

2.  执行后续操作，操作结束后删除Key。

   ​	存在的问题：1.死锁，2.锁被别人释放；3.锁过期时间不好评估

   ​    解决1：  `SET lock $uuid EX 20 NX`    设置过期时间

   ​    解决2:    `#伪代码 if (redis.get("lock") == $uuid) {redis.del("lock")} ` 

   ​                 但是要保证解除锁的原子性，用Lua脚本，Redis是单线程的，执行一个Lua脚本，其他请求必须等待；

   ```
   // 判断锁是自己的，才释放
   if redis.call("GET",KEYS[1]) == ARGV[1]
   then
       return redis.call("DEL",KEYS[1])
   else
       return 0
   end
   ```

      解决3：【守护线程】Redisson 续锁

      **以上都是Redis单部署情况下的问题解决方案**

### RabbitMQ 以及mqtt

1. 平时使用消息队列是AMQP协议
2. 智能硬件是MQTT协议,将发布者和订阅者进行了分离，不可靠网络环境下，为远程设备提供可靠的消息服务
3. MQTT在应用层，构建于TCP/IP协议上
4. RabbiMQ如何保证幂等性？
   1. MQ对每一条消息都会生成一个唯一id,作为去重依据（消息投递失败重传），避免消息重复进入队列
   2. 消费消息时，在消息体中必须要有一个业务的唯一id,作为业务去重的依据，避免同一条消息被消费2次
5. 如何保证消息正确的发送到RabbitMq？如何保证接收方消费了消息？
   1. 发送方-->mq：开启confirm模式，所有信息都会指派一个唯一id,消息被投递到mq后，会返回这个唯一id确认给消费者。
   2. mq --> 接收方：开启手动ack确认，业务完成后，再返回ack确认。

### sql慢查询

1. 开启慢查询

   1. `SET GLOBAL slow_query_log = ON;` 

   2. 知识扩展：

      ```
      默认情况下，慢查询日志中不会记录管理语句，可通过设置 log_slow_admin_statements = on 让管理语句中的慢查询也会记录到慢查询日志中。
      
      默认情况下，也不会记录查询时间不超过 long_query_time 但是不使用索引的语句，可通过配置 log_queries_not_using_indexes = on 让不使用索引的 SQL 都被记录到慢查询日志中（即使查询时间没超过 long_query_time 配置的值）。
      ```

      

2. 设置慢查询阀门值

   1. `set global long_query_time = 1;`

   2. ```
      知识扩展：
      MySQL 中 long_query_time 的值如何确定呢？
      
      线上业务一般建议把 long_query_time 设置为 1 秒，如果某个业务的 MySQL 要求比较高的 QPS，可设置慢查询为 0.1 秒。发现慢查询及时优化或者提醒开发改写。
      
      一般测试环境建议 long_query_time 设置的阀值比生产环境的小，比如生产环境是 1 秒，则测试环境建议配置成 0.5 秒。便于在测试环境及时发现一些效率低的 SQL。
      
      甚至某些重要业务测试环境 long_query_time 可以设置为 0，以便记录所有语句。并留意慢查询日志的输出，上线前的功能测试完成后，分析慢查询日志每类语句的输出，重点关注 Rows_examined（语句执行期间从存储引擎读取的行数），提前优化。
      ```

3. 确定慢查询日志路径和文件名

   `show global variables like "datadir";`

   `show global variables like "slow_query_log_file";`

4. druid连接池也带有慢查询监控

### RPC  分布式锁 线程池 定时任务

#### 什么是RPC？

- 首先客户端需要告诉服务器，需要调用的函数，这里**函数和进程ID存在一个映射**，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。
- 客户端需要把本地参数传给远程函数，**本地调用的过程中，直接压栈**即可，但是在**远程调用**过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个**序列化和反序列化**的过程。
- 数据准备好了之后，如何进行传输？网络传输层需要把**调用的ID和序列化后的参数**传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。

```
// Client端 
//    Student student = Call(ServerAddr, addAge, student)
1. 将这个调用映射为Call ID。
2. 将Call ID，student（params）序列化，以二进制形式打包
3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层
4. 等待服务器返回结果
5. 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新

// Server端
1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map<String, Method> callIdMap
2. 等待客户端请求
3. 得到一个请求后，将其数据包反序列化，得到Call ID
4. 通过在callIdMap中查找，得到相应的函数指针
5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果
6. 将student结果序列化后通过网络返回给Client
```

#### RestFul和RPC的区别

- 从本质区别上看，RPC是基于TCP实现的，RESTFUL是基于HTTP来实现的。
- 从传输速度上来看，因为HTTP封装的数据量更多所以数据传输量更大，所以RPC的传输速度是比RESTFUL更快的。

- 因为HTTP协议是各个框架都普遍支持的。在toC情况下，因为不知道情况来源的框架、数据形势是什么样的，所以在网关可以使用Restful利用http来接受。而在微服务内部的各模块之间因为各协议方案是公司内部自己定的，所以知道各种数据方式，可以使用TCP传输以使各模块之间的数据传输更快。所以可以网关和外界的数据传输使用RESTFUL，微服务内部的各模块之间使用RPC。

- RESTFUL的API的设计上是面向资源的，对于同一资源的获取、传输、修改可以使用GET、POST、PUT来对同一个URL进行区别，而RPC通常把动词直接体现在URL上。

### 多线程

#### 	多线程的4种方式

- 实现runnable接口，重写run方法，new Thread(对象).start 启动
- 实现callable接口，重写call方法 ,FutureTask封装返回值
- 继承Thread类，重写run方法    对象.start启动
- Thread t = new Thread(() -> {})
- 线程池
  - newFixedThreadPool 固定线程池
  - newCachedTreadPool 缓冲线程池
  - newSingleThreadExecutor 单线程线程池
  - newScheduledThreadPool 调度线程池

### 线程间通信方式

- volatile关键字，共享内存你，多个线程监听这个变量 （可见性和有序性）
- wait()、notify()、notifyAll(),配合synchronize使用
- JUC工具类CountDownLatch，基于AQS,维护线程共享变量

### spring

1. 依赖循环 
   1. 构造注入 没办法解决
   2. 前提：构建的所有对象都是单例对象
   3. setter注入 通过三级缓存解决
2. IOC
   1. 控制反转，容器，统一管理
3. AOP
   1. 动态代理
      1. JDK
      2. CGLib
   2. 术语
      1. 切面
      2. 横切关注点
      3. 连接点
      4. 切入点
      5. 通知
      6. 目标对象
      7. 织入

### mybatis二级缓存

### bitmap

用bit位来存 1 表示存在，0表示不存在

优点：省内存 ，运算效率高

缺点：所有数据不能重复，只有数据比较密集才有优势



数据一致性，分布式事务，分布式事务框架，选型原因



注册中心的使用？AP还是CP？如何决定

CAP  

1. C：一致性

2. A:  可用性 

3. P：分区容错性  （服务间的调用容错，分布式这个是一定满足的，所以只能从CP和AP中选）

   一般都是牺牲强一致性，保证AP，可用性和分区容错性

CPU飙升，如何排查



