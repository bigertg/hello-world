1. http 三次握手 四次挥手 以及请求头信息

   1. 三次握手（确认双方都能正常发送和接收）

      1. 一次握手 -- 客户端-  发送标有SYN的数据包         -服务端
      2. 二次握手 -- 服务端-  发送标有SYN/ACK的数据包 -客户端
      3. 三次握手 -- 发送端-   发送标有ACK的数据包           -服务端

   2. 四次挥手(要求双方都完毕)

      1. 客户端-发送FIN用来关闭客户端到服务器的数据传送
      2. 服务端-收到FIN，返回ACK
      3. 服务端-关闭连接，发送一个FIN给客户端
      4. 客户端-发回ACK报文确认

   3. 根据真实ip限制地区访问

      1. 基本逻辑：获取用户ip地址，如果是内网ip，直接通过，如果是外网ip,使用第三方接口（百度普通ip定位）进行查询，根据返回的地址进行判断是否拥有该活动权限

      2. 请求头

         1. X-Forwarded-For 每经过一个代理，都会把代理客户端ip添加在后面
         2. X-Real-IP  上一级代理的客户端ip
         3. Remote_Addr  最后一个代理的服务器IP，如果没有代理则为真实IP

         

2. 单点登入 

   1. Spring Security + jwt +redis 
   2. JWT 
      1. 无状态设计，用户信息存在jwt密文数据里，解析密文就能拿到用户信息，本质上就是不存储登入授权，减少数据库压力
      2. 头部、荷载、签名
         1. 头部：描述JWT元数据的JSON对象
         2. 荷载：消息体，可根据业务需求自行添加
         3. 签名sign: 将头部和荷载分别用base64加密后，用‘.’拼接后再配合秘钥(自定义)HMAC SHA-256进行加密，最后再次base64加密
      3. 缺点：一旦jwt签发，有效期内一直有效，无法进行token失效操作
   3. SpringSecurity 身份认证和授权
      1. 不同方式的用户登入
         1. 自定义类继承AbstractAuthenticationToken抽象类（账号密码）
         2. 自定义一个AuthenticationProvider实现类（可以写验证逻辑），重写authenticate方法和supports方法（要根据这个去适配自定义的AuthenticationToken类）
         3. 在配置文件进行注册
      2. 插入自定义过滤器
      3. 插拔式加解密方式
   4. JWT加密token(key),Redis保存用户信息

3. 微服务拆分的粒度

   1. 
      1. 分2种类型，一种类似OA系统，业务相对独立；另一种类似资产管理，底层耦合较重
      2. 应用功能拆，数据库也要拆
      3. 数据怎么拆，尽量减少跨库查询和分布式事务
   2. 分离出非核心业务
      1. 检验行为
      2. 短信、邮件发送
   3. 分析业务，将比较独立的业务拆分成一个微服务
   4. 如果数据层耦合较重，则分析业务的每个阶段，根据不同阶段关联性的强弱来划分，尽量减少跨库查询和分布式事务

4. AES接口参数加密

   1. 基本流程：前端使用AES对接口进行加密，同时生成sign标签，sign标签页放入到加密数据中 -----> 后端接收密文后先解密，再验签，验签失败则为无效数据
      1. 加密：AES
         1. AES是对称加密算法 C=E(K，P)  C:经过处理后的密文，E:AES加密函数，K:秘钥(128位 192位 256位)，P：明文
         2. AES-128 加密10轮，AES-192 12轮，AES-256 14轮  前面N-1轮都是统一流程：字节代换、行位移、列混合和轮密钥加；最后一轮迭代不执行列混合
         3. 秘钥（自定义）：请求头token + 时间戳前八位   
      2. Sign标签（MD5生成摘要）
         1. 生成规则：所有请求参数，random(随机数)，timestamp  , token,根据key值排序，以key=value&拼接成字符串，再进行MD5加密
         2. 校验：后端拦截器，根据此方法进行MD5加密，校验 一致性，再进行AES解密
         3. 遇到的问题，request的参数只能读取一次，使用包装类解决问题

5. Redis的使用有什么作用

   1. 缓存
   2. 分布式锁
   3. 消息队列
   4. 淘汰策略

6. Redis + token实现幂等性

   1. 第一阶段：在提交订单之前，根据用户信息向订单系统申请一次token请求，支付系统将token保存到Redis缓存中，为第二阶段支付使用
   2. 第二阶段：带上token发起支付请求，系统查看redis是否存在此token，如果存在，则删除缓存开始后续逻辑；如果不存在，表示非法请求；

    

   **拓展**：Redis分布式锁

   1. ​	查询Redis缓存是否存在该订单的key,如果不存在，则新增key为订单号（直接插入）SETNX

      1. SETNX (set if not exists)  SETNX key value当且仅当key不存在，将key的值设为value,并返回1；若key已存在，不做任何动作，并返回0   ---------------这个已经过时了，用set加参数同样能实现
      2. GETSET key value 将给定的值设为value,并返回key的旧值，当key存在但不是字符串，返回一个错误，当key不存在时，返回nil。
      3. SET key value EX  $expire_time NX     EX：设置过期时间    NX:  只有当值不存在时才操作，成功返回OK，失败返回nil（相当于SETNX）

   2.  执行后续操作，操作结束后删除Key。

      ​	存在的问题：1.死锁，2.锁被别人释放；3.锁过期时间不好评估

      ​    解决1：  `SET lock $uuid EX 20 NX`    设置过期时间

      ​    解决2:    `#伪代码 if (redis.get("lock") == $uuid) {redis.del("lock")} ` 

      ​                 但是要保证解除锁的原子性，用Lua脚本，Redis是单线程的，执行一个Lua脚本，其他请求必须等待；

      ```
      // 判断锁是自己的，才释放
      if redis.call("GET",KEYS[1]) == ARGV[1]
      then
          return redis.call("DEL",KEYS[1])
      else
          return 0
      end
      ```

         解决3：【守护线程】Redisson 续锁

         **以上都是Redis单部署情况下的问题解决方案**

7. RabbitMQ 以及mqtt

   1. 平时使用消息队列是AMQP协议
   2. 智能硬件是MQTT协议,将发布者和订阅者进行了分离，不可靠网络环境下，为远程设备提供可靠的消息服务
   3. MQTT在应用层，构建于TCP/IP协议上

8. 自主开发的网关 

9. sql慢查询

   1. 开启慢查询

      1. `SET GLOBAL slow_query_log = ON;` 

      2. 知识扩展：

         ```
         默认情况下，慢查询日志中不会记录管理语句，可通过设置 log_slow_admin_statements = on 让管理语句中的慢查询也会记录到慢查询日志中。
         
         默认情况下，也不会记录查询时间不超过 long_query_time 但是不使用索引的语句，可通过配置 log_queries_not_using_indexes = on 让不使用索引的 SQL 都被记录到慢查询日志中（即使查询时间没超过 long_query_time 配置的值）。
         ```

         

   2. 设置慢查询阀门值

      1. `set global long_query_time = 1;`

      2. ```
         知识扩展：
         MySQL 中 long_query_time 的值如何确定呢？
         
         线上业务一般建议把 long_query_time 设置为 1 秒，如果某个业务的 MySQL 要求比较高的 QPS，可设置慢查询为 0.1 秒。发现慢查询及时优化或者提醒开发改写。
         
         一般测试环境建议 long_query_time 设置的阀值比生产环境的小，比如生产环境是 1 秒，则测试环境建议配置成 0.5 秒。便于在测试环境及时发现一些效率低的 SQL。
         
         甚至某些重要业务测试环境 long_query_time 可以设置为 0，以便记录所有语句。并留意慢查询日志的输出，上线前的功能测试完成后，分析慢查询日志每类语句的输出，重点关注 Rows_examined（语句执行期间从存储引擎读取的行数），提前优化。
         ```

   3. 确定慢查询日志路径和文件名

      `show global variables like "datadir";`

      `show global variables like "slow_query_log_file";`

   4. druid连接池也带有慢查询监控

10. RPC  分布式锁 线程池 定时任务

11. 线程间通信方式

12. 依赖循环 

    1. 构造注入 没办法解决
    2. setter注入 通过三级缓存解决

13. mybatis二级缓存

14.  bitmap

15. 数据一致性，分布式事务，分布式事务框架，选型原因

16. 注册中心的使用？AP还是CP？如何决定

17. CPU飙升，如何排查

    

    